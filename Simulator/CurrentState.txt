-虽然在Commit时提及了， 不过为了方便查看在这里重新转述/表达下。

1 Eclipse用户加载主类Simulat.java (没错， 就是少个e而且没有or，坑爹eclipse不让我改Simulator.java因为有个netbeans的project在)
Netbeans用户导入后直接用Simulator就可以。

2目前的GUI仅仅只是测试用， 暂时还没有和赵悠/其他UI连接， 不过重要的一些接口都已经在对应class实现， 到时候只需要传递一个CPU实例就可以了。

3 指令目前的逻辑
假如是正常模式：
LoadMemory后，如果又进一步特殊指定了PC值，就按照指定值开始执行指令，否则就以最小可用内存 6为PC初值。
//---Cache:
//指令顺序执行除非jump-->jump的存在决定了内存中的指令和data可能是不连贯存储的-->非连贯决定了Cache的miss rate的情况并非对任何载入的内存镜像都是一样的。
//--同时， 目前未知的一点是是否有指令缓存和数据缓存分开的要求存在，需要确认下。 
//可能存在的情况似乎如下
//a 分开存储各自缓存。
//b 不区分且各自缓存
//c 不区分， 缓存data但不缓存inst.
PC-->MAR.
MemoryRead(MAR)-->IR
IR Execute.
Execute逻辑根据callback的实现方法决定。
a 所以需要经由内存（进/出）的数据都需要先经过MBR
b 内存的访问，地址需要保存在MAR
c 寄存器之间的通讯不总是可行的。


Single Step有至少两种可行的方法
首先不论哪一种都需要Load的内存镜像或者手动设定的各种寄存器/内存初值
--1 CPU中有只需要Instruction 16bit数值就可以运行的静态方法， 直接run。
--2 将他作为正常Execute的简化，将手动输入的指令编译后， 按照PC值先写回内存， 按照Execute的常规方式开始且仅执行一次。  
由于SIngle Step主要作用似乎是测试，应该不必纠结。
-------------------------------------------------------------------------------------
4需要做的
--1包括LDX等检查参数的指令， 以及细节到访问内存的基本操作，凡是对输入值有条件的操作都需要handle exception. 对exception还不是很熟。
--2 内存的检查为
（a）不超过4096，不过这个控制不需要内存访问进行，由于逻辑上他是bit-size限制的，直接在对MAR赋值等过程中设置有效大小即可。
 (b) 不超过当前内存大小。
 (c)  禁止在通常情况下访问0~5的预留区域。  （或者不是禁止，这个Reserved程度需要确认）。

--3 完整指令的实现，包括sleep、或者是否和Thread有关等。 目前还留着，等基本逻辑的监测没有异常之后实现。     
--4 CC中由于当时没有详细读文档，有疏漏--》目前实现的是ZSCF四类，需要微调下。


---------------------------------------------------------------------------------------------
5目前和DesignDocument不同的
(1) Register的类详细化了， 但Extends一个Register类，基本方法在Register类实现。
（2） Register类中有些不需要的代码和逻辑，不过并未被使用，可以直接删除。如 有一个byte[2]的副本。不过目前没见到用处，以后应该也用不到。
（3）Memory和Cache： Cache目前还留着， 但Memory和Cache的本体是实例中的short数组，而不是Register数组，传递直接通过值进行，不考虑传入的是何种寄存器。
---- 不过我想了下Register数组的好处也许会在Print体现，由于Register是一个输入，可以直接用一个Name成员负责在memory的读写方法中print（而不必在callback中进行）。
但不建议传递一整个实例，clone也得注意点。--总之这个逻辑貌似有点古怪。 可以详细讨论。

（4） 暂时没有修改的部分是 寄存器和memory的data类型是short而不是int。  码过程中感受到的优缺点在Document中有提及。  不过这点修改起来较为方便。 基本只需要修改声明方式+限制大小即可。  short需要注意的是位移操作等会自动将他转为int，记得考虑位数变化。





